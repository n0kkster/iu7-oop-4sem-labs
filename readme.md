# ООП

## Лекция 1

Суть структурного программирования - разбиение задачи на атомарные функции. Нисходящий подход. Основная задача разбивается на мн-во меньших подзадач, которые в свою очередь тоже разбиваются. На нижних уровнях логика отсутствует. Логика присутствует только на верхних уровнях.

**Управление:**
```
            -----------------
            |    главная    |
            |    функция    |
            |               |
            -----------------
            /       |       \
           /        |        \
          /         |         \
         /          |          \
------------- ------------- -------------
|подфункция | |подфункция | |подфункция |
|         1 | |          2| |          3|
------------- ------------- -------------
```

- У руководителя (вызывающей функции) должно быть не более 7 подчиненных (вызывыемых функций). Нужно не допускать разрастание дерева управления в ширину.
- Глубина вложенности конструкций в функции не должна быть больше 3.
- Выход из цикла должен быть только один.
- Никаких `goto`.


**Основные принципы написания функций типа "черный ящик":**
- Проверки данных делать внутри функций. Не думать о других функциях.
- Если функция не может выполниться, она возвращает управление вызывающей функции. Не использовать `abort()`, `exit()`, `assert()`.
- Функция должна выполнять какое-то одно действие. Определение действия функции должно быть коротким, а также не включать перечисления и обороты. Оборот - проброс указания от функции выше к функции ниже.
- Не должно быть разных функций, выполняющих одно действие, а также дублирования кода.
- Параметры в функциях делятся на:
    - Входные. Обязательно инициализированы. Функция не имеет права их менять.
    - Выходные. Не должны быть инициализированы. 
    - Изменяемые. Обязательно должны быть инициализированы. Если функция не может быть выполнена, то она не должна изменять данные параметры.
- Если функция не может выполниться, она не должна захватывать ресурсы. Обязательно освободить все, что захватила. Если же функция выполнилась, то захваченные ресурсы возвращаются на верхний уровень. Вызывающая функция теперь ответственна за них.
- Все данные в функции должны быть переданы явно (то есть не использовать глобальных). Константы, которые никогда не поменяются, могут быть глобальными (например Пи, у нас не поменяется, в отличие от ~~хохлов~~ украинцев. © Тассов).
- Сокращать количество передаваемых параметров. Желательно, чтобы было не больше трех. Можно структурировать параметры.
- Необходимо передавать в функцию только то, с чем она работает. Например если есть структура на много полей, а функция работает только с несколькими из них, не стоит тащить всю структуру. Можно создать меньшую структуру. **Не работать с полями полей структуры.**
- Стараться протащить данные как можно ниже. То есть чтобы на верхних уровнях было меньше данных и были только те, которые нужны на текущем уровне.

---

## Лекция 2

### **Плюсы СП:**
- Логические ошибки исправляются на ранних стадиях разработки.
- Комплексная отладка. Подзадачи можно тестировать в составе большей задачи. Не нужно писать тесты для каждой подзадачи, нужно писать тесты на всей программы.
- Не нужно полностью выполнять проект. Проектируем -> пишем код -> тестируем и так по кругу.
- Разбиваем задачи на подзадачи. Получается иерархическая структура, уровни абстракции. Каждая функция должна быть небольшой.
- Плавное распределение ресурсов.

---

## Лекция 3

### **Недостатки ООП:**
- Необходимо выполнить серьезную работу для получения начальной модели. Пока эта модель не будет получена, нельзя переходить к кодированию.
- Порог вхождения в ООП довольно высокий.
- Резкое разрастание кода (=> увеличивается время компиляции).
- Мертвый код (какие-то поля классов могут не использоваться). В современных языках решается с помощью JIT-компиляции (компиляция нужных методов происходит при необходимости, при использовании). При использовании JIT-компиляции можно вносить изменения в программу на горячую.
- Полиморфизм увеличивает время выполнения программы.

Все эти недостатки перекрываются простой модификации программы. Уже написанный код не выкидывается.

### **Понятия ООП.**

**Объект** - это абстрактная реализация какого-то типа, которая обладает характеристиками состояния, поведения и индивидуальности.

**Состояние** - один из возможных вариантов существования объекта.

**Поведение** - описание объекта в терминах изменения его состояния. 

Правила перехода определяют какое новое состояние примет объект, если с ним в данном состоянии произойдет данное событие.
С каждым состоянием будет связано действие (действие состояние). Задача этого действия - перевести объект в это состояние.
**В ООП не использовать switch.**

Реальные объекты - это такие объекты, которые существуют в физическом мире. С них мы начинаем формализацию. В дальнейшем они обрастают другими объектами.

Один физический объект может выполнять несколько **ролей**. В ООП на каждый объект возлагается только **одна** роль.
Роль - это абстракция, цель или назначение. Например для человека: студент, преподаватель, сотрудник. В программе каждый объект выполняет только одну роль, в отличие от физ. мира.

**Инциденты** - абстракция чего-то случившегося. Наводнение, скачок напряжения, выборы. Инциденты проходят через некоторые стадии и приходят в заключительное состояние. 

**Объекты взаимодействия** - объекты, которые получаются из взаимодействия других объектов.

**Спецификации** - используется для представления каких-то стандартов, критериев качества, правил. Пассивные объекты, предназначены для информирования. Расписание движения поездов, ПДД, и тд..

Отношения между объектами:
- Отношение использования (старшинства). Объекты выступают в трех ролях:
    - Воздействующие объекты - объекты, которые воздействуют на других, но сами не подвержены воздействию других объектов.
    - Исполнители - объекты, которые управляются другими объектами, но сами никогда не выступают в роли воздействующих.
    - Посредники - объекты, которые могут воздействовать и подвергаться воздействию.
- Отношение включения - объект может включать в себя другие объекты.

**Класс** - абстракция множества предметов реального мира, что все предметы в этом мире имеют одни и те же характеристики и общее поведение.

Класс вступает в следующие отношения:
- Наследование
- Использование - класс использует другие классы.
- Включение - определяем класс внутри другого класса. 

**Домен** - отдельный реальный или гипотетический мир, населенный отчетливым набором объектов, которые ведут себя в соответствии с характерными для домена правилами и линиями поведения.